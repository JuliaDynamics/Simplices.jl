"""
    binary()
'labels' contains labels of boundaries that are not generated exclusively by contained vertices.
For each of these label, at least one of the generating vertices are not contained in the other simplex.
This function translates each label into a binary array. Each number is transformed
into its binar yexpression as if you had N+1 bits.

The array of 0's and 1's

Input arguments
---------------
m::                  Column array of numbers whose binary expressions we want to extract
n::                 Maximum power in the binary decomposition
labels::Vec{Int}     Contains a label ordering for all possible boundaries. Labels take values in the range 1:2^(dim+1)-2 (but not all of them), except for the first  2^Nin - 1, where Nin is the minimum number of contained vertices. Exclude the maximum because it corresponds to the whole simplex.
dimension::Int      Previuously 'n' The dimension of the space.
Returns
-------
boundary_binary_labels::Array{Int, 2} Matrix of 0's and 1's. Each row represents a number contained in 'labels'. The columns for this row is the binary expansion of this number in D+1 bits. Each column of this matrix contains a vertex generating a generic simplex. If there is a zero in a particular row, it means that the corresponding boundary is not generated by that vertex.
"""
function Binary(m, n)
    # m: column array of numbers whose binary expressions we want to extract
    # n: maximum power in the binary decomposition

    # OUTCOME:
    # array of dimension size(m,2) x (n+1)
    # each row contains the binary decomposition of the corresponding entry
    # in m, that is
    # (thea(1),...,theta(n+1)) \in {0,1}^{(n+1)}
    # such that m = \sum_{k=0}^{n} theta(k+1)*2^k

    exponent = repeat(transpose(float(2) .^ (-(collect(0:n)))), size(m, 1), 1)
    m = repeat(m, 1, n + 1)

    binary = m .* exponent
    binary = floor.(Int64, binary)
    binary[:, 1:n] = binary[:, 1:n] - 2 * binary[:, 2:(n + 1)]

    return binary
end
